!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.dirtvz=n():e.dirtvz=n()}(self,()=>(()=>{"use strict";var __webpack_modules__={"./ts/local-loader.ts":(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SpatialObject: () => (/* binding */ SpatialObject),\n/* harmony export */   parse_file: () => (/* binding */ parse_file)\n/* harmony export */ });\n/* harmony import */ var _wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wasm */ \"./ts/wasm.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_wasm__WEBPACK_IMPORTED_MODULE_0__]);\n_wasm__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nclass SpatialObject {\n    name;\n    obj;\n    constructor(name, obj) {\n        this.name = name;\n        this.obj = obj;\n    }\n}\nasync function parse_file(file) {\n    let name = file.name;\n    let ext = name.split('.').slice(1).pop();\n    if (ext === undefined)\n        ext = '';\n    let len = name.length - ext.length - (ext.length == 0 ? 0 : 1);\n    let name2 = name.substring(0, len);\n    let data = await file.arrayBuffer().then(x => new Uint8Array(x));\n    if (data.byteLength > 2.2e9)\n        throw new Error('file is too large: a 2.2 GB limit is imposed');\n    switch (ext) {\n        case '':\n            throw new Error('file has no extension');\n        case '00t':\n            if (data.byteLength > 100e6)\n                throw new Error('file is too large: 00t must be smaller than 100 MB');\n            try {\n                let mesh = _wasm__WEBPACK_IMPORTED_MODULE_0__.TriangleMeshSurface.from_vulcan_00t(data);\n                return new SpatialObject(name2, mesh);\n            }\n            catch (error) {\n                throw new Error('unable to Vulcan file: ' + error);\n            }\n        default:\n            throw new Error('extension `' + ext + '` is currently unsupported');\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://dirtvz/./ts/local-loader.ts?")},"./ts/spatial-obj.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Status: () => (/* binding */ Status),\n/* harmony export */   add_root: () => (/* binding */ add_root),\n/* harmony export */   add_tile: () => (/* binding */ add_tile),\n/* harmony export */   has_root: () => (/* binding */ has_root),\n/* harmony export */   has_tile: () => (/* binding */ has_tile)\n/* harmony export */ });\nvar Status;\n(function (Status) {\n    Status["Unloaded"] = "unloaded";\n    Status["Preprocessing"] = "preprocessing";\n    Status["Loaded"] = "loaded";\n    Status["Ready"] = "ready";\n})(Status || (Status = {}));\nfunction cmpr(a, b) {\n    return a - b;\n}\nfunction add_root(o, tile) {\n    o.roots.push(tile);\n    o.roots.sort(cmpr);\n}\nfunction has_root(o, tile) {\n    return bsearch(o.roots, tile) >= 0;\n}\nfunction add_tile(o, tile) {\n    o.tiles.push(tile);\n    o.tiles.sort(cmpr);\n}\nfunction has_tile(o, tile) {\n    return bsearch(o.tiles, tile) >= 0;\n}\nfunction bsearch(array, value) {\n    let index = 0;\n    let limit = array.length - 1;\n    while (index <= limit) {\n        const i = Math.ceil((index + limit) / 2);\n        const e = array[i];\n        if (value > e) {\n            index = i + 1;\n        }\n        else if (value < e) {\n            limit = i - 1;\n        }\n        else {\n            return i; // value == e\n        }\n    }\n    return -1;\n}\n\n\n//# sourceURL=webpack://dirtvz/./ts/spatial-obj.ts?')},"./ts/store.ts":(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Store: () => (/* binding */ Store)\n/* harmony export */ });\n/* harmony import */ var _spatial_obj__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spatial-obj */ \"./ts/spatial-obj.ts\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! idb */ \"./node_modules/idb/build/index.js\");\n/* harmony import */ var _wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wasm */ \"./ts/wasm.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_wasm__WEBPACK_IMPORTED_MODULE_2__]);\n_wasm__WEBPACK_IMPORTED_MODULE_2__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nvar Key;\n(function (Key) {\n    Key[\"DataExtents\"] = \"data-extents\";\n    Key[\"ObjList\"] = \"object-list\";\n})(Key || (Key = {}));\nconst stores = ['root', 'raw-objs', 'tiles'];\nclass Store {\n    db_name;\n    db;\n    constructor(db_name, db) {\n        this.db_name = db_name;\n        this.db = db;\n    }\n    static async connect(db_name) {\n        const db = await idb__WEBPACK_IMPORTED_MODULE_1__.openDB(db_name, 1, {\n            upgrade(db) {\n                for (const n of stores)\n                    db.createObjectStore(n);\n            },\n            terminated: () => console.error(\"Browser abnormally closed connection to \" + db_name),\n        });\n        console.info(`Opened connection to '${db_name}'`);\n        return new Store(db_name, db);\n    }\n    async transact(store_name, mode, tfn) {\n        const tx = this.db.transaction(store_name, mode, { durability: 'relaxed' });\n        const store = new TypedStore(tx.store);\n        const x = await tfn(store);\n        await tx.done;\n        return x;\n    }\n    async extents() {\n        return this.transact('root', 'readonly', store => store.get_bytes(Key.DataExtents)\n            .then(bytes => {\n            if (bytes)\n                return _wasm__WEBPACK_IMPORTED_MODULE_2__.Extents3.from_bytes(bytes);\n            else\n                return undefined;\n        }));\n    }\n    async set_extents(extents) {\n        const objs = await this.get_object_list();\n        return this.transact('root', 'readwrite', async (store) => {\n            await store.put_bytes(Key.DataExtents, extents.to_bytes());\n            objs.forEach(x => x.status = _spatial_obj__WEBPACK_IMPORTED_MODULE_0__.Status.Preprocessing);\n            store.put(Key.ObjList, objs);\n            console.info({ msg: `Data extents set for '${this.db_name}'`, extents: extents.toString() });\n        });\n    }\n    async store_object(key, obj) {\n        // remove any previous object with that key\n        await this.delete_object(key);\n        // write the bytes out\n        await this.transact('raw-objs', 'readwrite', store => {\n            const bytes = obj.to_bytes();\n            return store.put_bytes(key, bytes);\n        });\n        const o = { key, status: _spatial_obj__WEBPACK_IMPORTED_MODULE_0__.Status.Preprocessing, roots: [], tiles: [] };\n        await this.update_object_list(o);\n        return o;\n    }\n    async get_object(key) {\n        return this.transact('raw-objs', 'readonly', async (store) => {\n            const bytes = await store.get_bytes(key);\n            if (bytes)\n                return _wasm__WEBPACK_IMPORTED_MODULE_2__.TriangleMeshSurface.from_bytes(bytes);\n            else\n                return undefined;\n        });\n    }\n    async delete_object(obj) {\n        const sobj = await this.find_object(obj);\n        const sobjs = await this.get_object_list();\n        const update_sobjs = this.transact('root', 'readwrite', store => store.put(Key.ObjList, sobjs.filter(x => x.key != obj)));\n        const rm_raw = this.transact('raw-objs', 'readwrite', store => store.delete(obj));\n        const rm_tiles = this.transact('tiles', 'readwrite', async (store) => {\n            if (!sobj)\n                return;\n            for (const t of sobj.tiles)\n                await store.delete(obj_tile_key(obj, t));\n        });\n        return Promise.all([update_sobjs, rm_raw, rm_tiles]);\n    }\n    async get_object_list() {\n        return this.transact('root', 'readonly', async (store) => {\n            return await store.get(Key.ObjList) ?? [];\n        });\n    }\n    async update_object_list(sobj) {\n        return this.transact('root', 'readwrite', async (store) => {\n            const objs = (await store.get(Key.ObjList) ?? []);\n            const idx = objs.findIndex(o => o.key == sobj.key);\n            if (idx > -1) {\n                objs[idx] = sobj;\n            }\n            else {\n                objs.push(sobj);\n            }\n            await store.put(Key.ObjList, objs);\n        });\n    }\n    async find_object(objkey) {\n        return (await this.get_object_list()).find(x => x.key == objkey);\n    }\n    async store_tile(obj, tile_idx, zs) {\n        await this.transact('tiles', 'readwrite', store => store.put_bytes(obj_tile_key(obj, tile_idx), new Uint8Array(zs.buffer)));\n        await this.transact('root', 'readwrite', async (store) => {\n            const sobjs = await store.get(Key.ObjList) ?? [];\n            const sobj = sobjs.find(x => x.key == obj);\n            if (!sobj)\n                return;\n            if (!(0,_spatial_obj__WEBPACK_IMPORTED_MODULE_0__.has_tile)(sobj, tile_idx))\n                (0,_spatial_obj__WEBPACK_IMPORTED_MODULE_0__.add_tile)(sobj, tile_idx);\n            if (_wasm__WEBPACK_IMPORTED_MODULE_2__.TileId.is_root(tile_idx) && !(0,_spatial_obj__WEBPACK_IMPORTED_MODULE_0__.has_root)(sobj, tile_idx))\n                (0,_spatial_obj__WEBPACK_IMPORTED_MODULE_0__.add_root)(sobj, tile_idx);\n            store.put(Key.ObjList, sobjs);\n        });\n    }\n    async get_tile(obj, tile_idx) {\n        return this.transact('tiles', 'readonly', async (store) => {\n            const bytes = await store.get_bytes(obj_tile_key(obj, tile_idx));\n            if (bytes)\n                return new Float32Array(bytes.buffer);\n            else\n                return undefined;\n        });\n    }\n}\nclass TypedStore {\n    store;\n    constructor(store) {\n        this.store = store;\n    }\n    async get(key) {\n        return this.store.get(key);\n    }\n    async put(key, obj) {\n        // @ts-ignore\n        await this.store.put(obj, key);\n    }\n    async get_bytes(key) {\n        let bytes = await this.get(key);\n        if (bytes)\n            return new Uint8Array(bytes);\n        else\n            return undefined;\n    }\n    async put_bytes(key, bytes) {\n        await this.put(key, bytes.buffer);\n    }\n    async delete(key) {\n        // @ts-ignore\n        await this.store.delete(key);\n    }\n}\nfunction obj_tile_key(obj, tile) {\n    return `${obj}/${tile}`;\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://dirtvz/./ts/store.ts?")},"./ts/wasm.ts":(module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Extents3: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.Extents3),\n/* harmony export */   Point3: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.Point3),\n/* harmony export */   TileHash: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.TileHash),\n/* harmony export */   TileId: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.TileId),\n/* harmony export */   TriangleMeshSurface: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.TriangleMeshSurface),\n/* harmony export */   VertexData: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.VertexData),\n/* harmony export */   ViewableTiles: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.ViewableTiles),\n/* harmony export */   Viewbox: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.Viewbox),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),\n/* harmony export */   __wbindgen_string_new: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_string_new),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw),\n/* harmony export */   memory: () => (/* reexport safe */ _wasmpkg_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__.memory)\n/* harmony export */ });\n/* harmony import */ var _wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../wasmpkg/wasm */ "./wasmpkg/wasm.js");\n/* harmony import */ var _wasmpkg_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../wasmpkg/wasm_bg.wasm */ "./wasmpkg/wasm_bg.wasm");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__, _wasmpkg_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);\n([_wasmpkg_wasm__WEBPACK_IMPORTED_MODULE_0__, _wasmpkg_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://dirtvz/./ts/wasm.ts?')},"./ts/worker.ts":(module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var threads_es_worker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! threads-es/worker */ "./node_modules/threads-es/worker/Worker.js");\n/* harmony import */ var threads_es_shared__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! threads-es/shared */ "./node_modules/threads-es/shared/TransferDescriptor.js");\n/* harmony import */ var _local_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./local-loader */ "./ts/local-loader.ts");\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "./ts/store.ts");\n/* harmony import */ var _wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wasm */ "./ts/wasm.ts");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_local_loader__WEBPACK_IMPORTED_MODULE_0__, _store__WEBPACK_IMPORTED_MODULE_1__, _wasm__WEBPACK_IMPORTED_MODULE_2__]);\n([_local_loader__WEBPACK_IMPORTED_MODULE_0__, _store__WEBPACK_IMPORTED_MODULE_1__, _wasm__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\nconst api = {\n    read_load_and_store_from_spatial_file,\n    preprocess_spatial_object,\n    build_vertex_data\n};\n(0,threads_es_worker__WEBPACK_IMPORTED_MODULE_3__.exposeApi)(api);\nasync function read_load_and_store_from_spatial_file(db_name, file) {\n    let obj = await _local_loader__WEBPACK_IMPORTED_MODULE_0__.parse_file(file);\n    let db = await _store__WEBPACK_IMPORTED_MODULE_1__.Store.connect(db_name);\n    await db.store_object(obj.name ?? \'new-object\', obj.obj);\n}\nasync function preprocess_spatial_object(db_name, objkey) {\n    const db = await _store__WEBPACK_IMPORTED_MODULE_1__.Store.connect(db_name);\n    const mesh = await db.get_object(objkey);\n    if (!mesh)\n        return;\n    let extents = await db.extents();\n    if (!extents) {\n        extents = mesh.aabb();\n        await db.set_extents(extents);\n    }\n    console.time(\'generating tiles hash\');\n    let hash = mesh.generate_tiles_hash(extents);\n    let tiles = hash.tiles();\n    console.timeEnd(\'generating tiles hash\');\n    for (const tile_idx of tiles) {\n        let zs = hash.sample(tile_idx);\n        if (zs)\n            await db.store_tile(objkey, tile_idx, zs);\n    }\n}\nfunction build_vertex_data(tile_idx, zs, extents) {\n    const xts = _wasm__WEBPACK_IMPORTED_MODULE_2__.Extents3.from_bytes(new Uint8Array(extents.send));\n    // const timer = `fill vertex data at ${lod_idx}`;\n    // console.time(timer);\n    const vd = _wasm__WEBPACK_IMPORTED_MODULE_2__.VertexData.fill_vertex_data_from_tile_zs_smooth(xts, tile_idx, new Float32Array(zs.send));\n    const empty = vd.is_empty();\n    const positions = empty ? new ArrayBuffer(0) : vd.positions().buffer;\n    const indices = empty ? new ArrayBuffer(0) : vd.indices().buffer;\n    const normals = empty ? new ArrayBuffer(0) : vd.normals().buffer;\n    let x = {\n        empty, positions, indices, normals\n    };\n    vd.free();\n    // console.timeEnd(timer);\n    return (0,threads_es_shared__WEBPACK_IMPORTED_MODULE_4__.Transfer)(x, [positions, indices, normals]);\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://dirtvz/./ts/worker.ts?')},"./wasmpkg/wasm.js":(module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Extents3: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Extents3),\n/* harmony export */   Point3: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Point3),\n/* harmony export */   TileHash: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.TileHash),\n/* harmony export */   TileId: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.TileId),\n/* harmony export */   TriangleMeshSurface: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.TriangleMeshSurface),\n/* harmony export */   VertexData: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.VertexData),\n/* harmony export */   ViewableTiles: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.ViewableTiles),\n/* harmony export */   Viewbox: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.Viewbox),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),\n/* harmony export */   __wbindgen_string_new: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_string_new),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw)\n/* harmony export */ });\n/* harmony import */ var _wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wasm_bg.wasm */ "./wasmpkg/wasm_bg.wasm");\n/* harmony import */ var _wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wasm_bg.js */ "./wasmpkg/wasm_bg.js");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);\n_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n(0,_wasm_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm)(_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_1__);\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://dirtvz/./wasmpkg/wasm.js?')},"./wasmpkg/wasm_bg.js":(module,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Extents3: () => (/* binding */ Extents3),\n/* harmony export */   Point3: () => (/* binding */ Point3),\n/* harmony export */   TileHash: () => (/* binding */ TileHash),\n/* harmony export */   TileId: () => (/* binding */ TileId),\n/* harmony export */   TriangleMeshSurface: () => (/* binding */ TriangleMeshSurface),\n/* harmony export */   VertexData: () => (/* binding */ VertexData),\n/* harmony export */   ViewableTiles: () => (/* binding */ ViewableTiles),\n/* harmony export */   Viewbox: () => (/* binding */ Viewbox),\n/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   __wbindgen_string_new: () => (/* binding */ __wbindgen_string_new),\n/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nfunction passArrayF64ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 8, 8) >>> 0;\n    getFloat64Memory0().set(arg, ptr / 8);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n*/\nclass Extents3 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Extents3.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    toJSON() {\n        return {\n            origin: this.origin,\n            size: this.size,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_extents3_free(ptr);\n    }\n    /**\n    * @returns {Point3}\n    */\n    get origin() {\n        const ret = wasm.__wbg_get_extents3_origin(this.__wbg_ptr);\n        return Point3.__wrap(ret);\n    }\n    /**\n    * @param {Point3} arg0\n    */\n    set origin(arg0) {\n        _assertClass(arg0, Point3);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_extents3_origin(this.__wbg_ptr, ptr0);\n    }\n    /**\n    * @returns {Point3}\n    */\n    get size() {\n        const ret = wasm.__wbg_get_extents3_size(this.__wbg_ptr);\n        return Point3.__wrap(ret);\n    }\n    /**\n    * @param {Point3} arg0\n    */\n    set size(arg0) {\n        _assertClass(arg0, Point3);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_extents3_size(this.__wbg_ptr, ptr0);\n    }\n    /**\n    * Returns the maximum size dimension.\n    *\n    * This is useful as the scaler value for working in _render_ space.\n    * @returns {number}\n    */\n    max_dim() {\n        const ret = wasm.extents3_max_dim(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * A default extents going from zero to one in all dimensions.\n    * @returns {Extents3}\n    */\n    static zero_to_one() {\n        const ret = wasm.extents3_zero_to_one();\n        return Extents3.__wrap(ret);\n    }\n    /**\n    * Transforms a _render_ coordinate into a _world_ coordinate by reversing the transform.\n    *\n    * Note that _x,y,z_ is in Y-up, such that y/z are swapped, but the returned world coordinate\n    * is in Z-up (so y/z will be swapped.)\n    *\n    * We assume that the render coordinate was initially calculated by using the extents\n    * (since this bounds the transformation).\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @returns {Point3}\n    */\n    render_to_world(x, y, z) {\n        const ret = wasm.extents3_render_to_world(this.__wbg_ptr, x, y, z);\n        return Point3.__wrap(ret);\n    }\n    /**\n    * Creates an extents with the origin at _x,y,z_ and size 0.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @returns {Extents3}\n    */\n    static from_pt(x, y, z) {\n        const ret = wasm.extents3_from_pt(x, y, z);\n        return Extents3.__wrap(ret);\n    }\n    /**\n    * Expand the extents to include this point.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    expand(x, y, z) {\n        wasm.extents3_expand(this.__wbg_ptr, x, y, z);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.extents3_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {Extents3}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.extents3_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Extents3.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass Point3 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Point3.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    toJSON() {\n        return {\n            x: this.x,\n            y: this.y,\n            z: this.z,\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_point3_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.__wbg_get_point3_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set x(arg0) {\n        wasm.__wbg_set_point3_x(this.__wbg_ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.__wbg_get_point3_y(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set y(arg0) {\n        wasm.__wbg_set_point3_y(this.__wbg_ptr, arg0);\n    }\n    /**\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.__wbg_get_point3_z(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} arg0\n    */\n    set z(arg0) {\n        wasm.__wbg_set_point3_z(this.__wbg_ptr, arg0);\n    }\n}\n/**\n*/\nclass TileHash {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TileHash.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tilehash_free(ptr);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    tiles() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tilehash_tiles(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Samples the mesh within a tile at the given spacing.\n    * @param {number} tile_idx\n    * @returns {Float32Array | undefined}\n    */\n    sample(tile_idx) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.tilehash_sample(retptr, this.__wbg_ptr, tile_idx);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass TileId {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TileId.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_tileid_free(ptr);\n    }\n    /**\n    * This tile a 'root' tile in the tessellating grid.\n    * @param {number} id\n    * @returns {boolean}\n    */\n    static is_root(id) {\n        const ret = wasm.tileid_is_root(id);\n        return ret !== 0;\n    }\n    /**\n    * This tile a 'root' tile in the tessellating grid.\n    * @returns {boolean}\n    */\n    is_root_() {\n        const ret = wasm.tileid_is_root_(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * This tile is at the deepest nesting level.\n    * @param {number} id\n    * @returns {boolean}\n    */\n    static is_max(id) {\n        const ret = wasm.tileid_is_max(id);\n        return ret !== 0;\n    }\n    /**\n    * This tile is at the deepest nesting level.\n    * @returns {boolean}\n    */\n    is_max_() {\n        const ret = wasm.tileid_is_max_(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * Represent this id as a single number.\n    * @returns {number}\n    */\n    as_num() {\n        const ret = wasm.tileid_as_num(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} n\n    * @returns {TileId}\n    */\n    static from_num(n) {\n        const ret = wasm.tileid_from_num(n);\n        return TileId.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    lod_res() {\n        const ret = wasm.tileid_lod_res(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    lod_lvl() {\n        const ret = wasm.tileid_lod_lvl(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n* A _surface_ spatial object consisting of a bunch of triangles.\n*\n* This object is meant to be fed into the `Viewer` object.\n* Since it will usually be transferred across the network, it is optimised for space.\n* It consists of an array of 'points' (x,y,z coordinates as 32-bit floats), an array of 'faces'\n* (32-bit indices of p1,p2,p3), and a translation `Point3`.\n*\n* The points are 32-bit to save on space. The translation point is recommended to be the lower\n* AABB point. Each point will be translated like so:\n* `translate` + `(x,y,z)`\n*/\nclass TriangleMeshSurface {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(TriangleMeshSurface.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_trianglemeshsurface_free(ptr);\n    }\n    /**\n    * @returns {Point3}\n    */\n    get translate() {\n        const ret = wasm.__wbg_get_extents3_origin(this.__wbg_ptr);\n        return Point3.__wrap(ret);\n    }\n    /**\n    * @param {Point3} arg0\n    */\n    set translate(arg0) {\n        _assertClass(arg0, Point3);\n        var ptr0 = arg0.__destroy_into_raw();\n        wasm.__wbg_set_extents3_origin(this.__wbg_ptr, ptr0);\n    }\n    /**\n    * Calculate the AABB of the mesh.\n    *\n    * Note that this returns in _real_ space, not translated space.\n    * @returns {Extents3}\n    */\n    aabb() {\n        const ret = wasm.trianglemeshsurface_aabb(this.__wbg_ptr);\n        return Extents3.__wrap(ret);\n    }\n    /**\n    * Deserialise a Vulcan 00t triangulation.\n    * @param {Uint8Array} data\n    * @returns {TriangleMeshSurface}\n    */\n    static from_vulcan_00t(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(data, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.trianglemeshsurface_from_vulcan_00t(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TriangleMeshSurface.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Extents3} extents\n    * @returns {TileHash}\n    */\n    generate_tiles_hash(extents) {\n        _assertClass(extents, Extents3);\n        const ret = wasm.trianglemeshsurface_generate_tiles_hash(this.__wbg_ptr, extents.__wbg_ptr);\n        return TileHash.__wrap(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    to_bytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.trianglemeshsurface_to_bytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} bytes\n    * @returns {TriangleMeshSurface}\n    */\n    static from_bytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.trianglemeshsurface_from_bytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return TriangleMeshSurface.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass VertexData {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VertexData.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_vertexdata_free(ptr);\n    }\n    /**\n    * Fills the component buffers of a babylonjs VertexData with a tile's meshes.\n    *\n    * This has quite a few semantics:\n    * - the grid x/y's are generated on the fly (in render space)\n    *   - (we assumes the zs are in render space)\n    * - the buffers are filled such that we are in _Y-up_ land\n    * - any `NaN`s are assumed nulls\n    *\n    * > _Consumes `zs` in the process, so it will not be available in JS afterwards._\n    * @param {Extents3} extents\n    * @param {number} tile_idx\n    * @param {Float32Array} zs\n    * @returns {VertexData}\n    */\n    static fill_vertex_data_from_tile_zs_smooth(extents, tile_idx, zs) {\n        _assertClass(extents, Extents3);\n        const ptr0 = passArrayF32ToWasm0(zs, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.vertexdata_fill_vertex_data_from_tile_zs_smooth(extents.__wbg_ptr, tile_idx, ptr0, len0);\n        return VertexData.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    is_empty() {\n        const ret = wasm.vertexdata_is_empty(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    positions() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vertexdata_positions(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayF32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    indices() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vertexdata_indices(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    normals() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.vertexdata_normals(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayF32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass ViewableTiles {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ViewableTiles.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_viewabletiles_free(ptr);\n    }\n    /**\n    * @param {Extents3} extents\n    * @returns {ViewableTiles}\n    */\n    static new(extents) {\n        _assertClass(extents, Extents3);\n        const ret = wasm.viewabletiles_new(extents.__wbg_ptr);\n        return ViewableTiles.__wrap(ret);\n    }\n    /**\n    * Calculate the tiles/lods in view and store them internally.\n    *\n    * The `viewbox_extents` is the AABB of **render space** in camera view.\n    * The `camera_dir` is a **render space** vector of the camera view direction.\n    * @param {Viewbox} viewbox\n    */\n    update(viewbox) {\n        _assertClass(viewbox, Viewbox);\n        wasm.viewabletiles_update(this.__wbg_ptr, viewbox.__wbg_ptr);\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    in_view_tiles() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.viewabletiles_in_view_tiles(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint32Array}\n    */\n    out_view_tiles() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.viewabletiles_out_view_tiles(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var v1 = getArrayU32FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 4);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* The camera's view box in **render space**.\n*\n* To build the view box, one can imagine the viewport defines 4 planes parallel to the camera\n* direction. These intersect with the min/max z world extents.\n*/\nclass Viewbox {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Viewbox.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_viewbox_free(ptr);\n    }\n    /**\n    * Build the viewbox.\n    *\n    * Unfortunately the interface is wonky to reduce the amount of serialisation that\n    * must pass through the WASM boundary.\n    * As such there are two arguments.\n    * The first one is the **data extents** in **world space**.\n    * The second is an array of floats representing **points in render space**,\n    * which will be destructured into:\n    * - camera direction\n    * - viewport (bottom-left)\n    * - viewport (bottom-right)\n    * - viewport (top-right)\n    * - viewport (top-left)\n    *\n    * That is, we expect an array of length 15 floats.\n    * If the length is not 15, we panic which will give weird WASM errors or might even\n    * silently fail.\n    * @param {Extents3} extents\n    * @param {Float64Array} data\n    * @returns {Viewbox}\n    */\n    static calculate(extents, data) {\n        _assertClass(extents, Extents3);\n        const ptr0 = passArrayF64ToWasm0(data, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.viewbox_calculate(extents.__wbg_ptr, ptr0, len0);\n        return Viewbox.__wrap(ret);\n    }\n}\n\nfunction __wbindgen_string_new(arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n\n\n//# sourceURL=webpack://dirtvz/./wasmpkg/wasm_bg.js?")},"./node_modules/idb/build/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: () => (/* binding */ deleteDB),\n/* harmony export */   openDB: () => (/* binding */ openDB),\n/* harmony export */   unwrap: () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   wrap: () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)\n/* harmony export */ });\n/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ \"./node_modules/idb/build/wrap-idb-value.js\");\n\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\n(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\n\n\n\n//# sourceURL=webpack://dirtvz/./node_modules/idb/build/index.js?")},"./node_modules/idb/build/wrap-idb-value.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ reverseTransformCache),\n/* harmony export */   i: () => (/* binding */ instanceOfAny),\n/* harmony export */   r: () => (/* binding */ replaceTraps),\n/* harmony export */   u: () => (/* binding */ unwrap),\n/* harmony export */   w: () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n\n\n\n//# sourceURL=webpack://dirtvz/./node_modules/idb/build/wrap-idb-value.js?")},"./node_modules/threads-es/shared/Messages.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ControllerMessageType: () => (/* binding */ ControllerMessageType),\n/* harmony export */   WorkerMessageType: () => (/* binding */ WorkerMessageType),\n/* harmony export */   assertMessageEvent: () => (/* binding */ assertMessageEvent)\n/* harmony export */ });\nvar ControllerMessageType;\n(function (ControllerMessageType) {\n    ControllerMessageType[ControllerMessageType["Run"] = 0] = "Run";\n    ControllerMessageType[ControllerMessageType["Cancel"] = 1] = "Cancel";\n    ControllerMessageType[ControllerMessageType["Terminate"] = 2] = "Terminate";\n})(ControllerMessageType || (ControllerMessageType = {}));\nvar WorkerMessageType;\n(function (WorkerMessageType) {\n    WorkerMessageType[WorkerMessageType["Init"] = 0] = "Init";\n    WorkerMessageType[WorkerMessageType["UnchaughtError"] = 1] = "UnchaughtError";\n    WorkerMessageType[WorkerMessageType["TaskError"] = 2] = "TaskError";\n    WorkerMessageType[WorkerMessageType["TaskResult"] = 3] = "TaskResult";\n})(WorkerMessageType || (WorkerMessageType = {}));\nfunction assertMessageEvent(event) {\n    if (!(event instanceof MessageEvent))\n        throw new Error("Not MessageEvent");\n}\n\n\n//# sourceURL=webpack://dirtvz/./node_modules/threads-es/shared/Messages.js?')},"./node_modules/threads-es/shared/TransferDescriptor.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transfer: () => (/* binding */ Transfer),\n/* harmony export */   isTransferDescriptor: () => (/* binding */ isTransferDescriptor)\n/* harmony export */ });\nconst $transferable = Symbol("threads-es.transferable");\nfunction isTransferDescriptor(thing) {\n    return thing && typeof thing === "object" && thing[$transferable];\n}\nfunction Transfer(payload, transferables) {\n    if (!transferables) {\n        transferables = [payload];\n    }\n    return {\n        [$transferable]: true,\n        send: payload,\n        transferables\n    };\n}\n\n\n//# sourceURL=webpack://dirtvz/./node_modules/threads-es/shared/TransferDescriptor.js?')},"./node_modules/threads-es/worker/Utils.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertSharedWorkerScope: () => (/* binding */ assertSharedWorkerScope),\n/* harmony export */   assertWorkerScope: () => (/* binding */ assertWorkerScope),\n/* harmony export */   isDedicatedWorkerScope: () => (/* binding */ isDedicatedWorkerScope),\n/* harmony export */   isSharedWorkerContext: () => (/* binding */ isSharedWorkerContext),\n/* harmony export */   isSharedWorkerScope: () => (/* binding */ isSharedWorkerScope),\n/* harmony export */   isWorkerScope: () => (/* binding */ isWorkerScope)\n/* harmony export */ });\nfunction isWorkerScope(scope) {\n    return typeof WorkerGlobalScope !== "undefined" && scope instanceof WorkerGlobalScope;\n}\nfunction assertWorkerScope(scope) {\n    if (!isWorkerScope(scope))\n        throw new Error("Not in a WebWorker");\n}\nfunction isDedicatedWorkerScope(scope) {\n    return typeof DedicatedWorkerGlobalScope !== "undefined" && scope instanceof DedicatedWorkerGlobalScope;\n}\nfunction isSharedWorkerScope(scope) {\n    return typeof SharedWorkerGlobalScope !== "undefined" && scope instanceof SharedWorkerGlobalScope;\n}\nfunction assertSharedWorkerScope(scope) {\n    if (!isSharedWorkerScope(scope))\n        throw new Error("Not in a shared web worker");\n}\nfunction isSharedWorkerContext(context) {\n    return context instanceof MessagePort;\n}\n\n\n//# sourceURL=webpack://dirtvz/./node_modules/threads-es/worker/Utils.js?')},"./node_modules/threads-es/worker/Worker.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   exposeApi: () => (/* binding */ exposeApi)\n/* harmony export */ });\n/* harmony import */ var _shared_Messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/Messages.js */ "./node_modules/threads-es/shared/Messages.js");\n/* harmony import */ var _shared_TransferDescriptor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shared/TransferDescriptor.js */ "./node_modules/threads-es/shared/TransferDescriptor.js");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils.js */ "./node_modules/threads-es/worker/Utils.js");\n\n\n\nfunction postModuleInitMessage(context, methodNames) {\n    const initMsg = {\n        type: _shared_Messages_js__WEBPACK_IMPORTED_MODULE_0__.WorkerMessageType.Init,\n        methodNames: methodNames\n    };\n    context.postMessage(initMsg);\n}\nfunction postUncaughtErrorMessage(context, error) {\n    try {\n        const errorMessage = {\n            type: _shared_Messages_js__WEBPACK_IMPORTED_MODULE_0__.WorkerMessageType.UnchaughtError,\n            errorMessage: error.message\n        };\n        context.postMessage(errorMessage);\n    }\n    catch (subError) {\n        console.error("Not reporting uncaught error back to master thread as it " +\n            "occured while reporting an uncaught error already." +\n            "\\nLatest error:", subError, "\\nOriginal error:", error);\n    }\n}\nfunction prepareResult(rawResult) {\n    if ((0,_shared_TransferDescriptor_js__WEBPACK_IMPORTED_MODULE_1__.isTransferDescriptor)(rawResult)) {\n        return { result: rawResult.send, transferables: rawResult.transferables };\n    }\n    else {\n        return { result: rawResult, transferables: [] };\n    }\n}\nfunction postWorkerTaskResultMessage(context, taskUid, rawResult) {\n    const { result, transferables } = prepareResult(rawResult);\n    const taskResultMessage = {\n        type: _shared_Messages_js__WEBPACK_IMPORTED_MODULE_0__.WorkerMessageType.TaskResult,\n        uid: taskUid,\n        result: result\n    };\n    context.postMessage(taskResultMessage, transferables);\n}\nfunction postWorkerTaskErrorMessage(context, taskUid, error) {\n    const taskErrorMessage = {\n        type: _shared_Messages_js__WEBPACK_IMPORTED_MODULE_0__.WorkerMessageType.TaskError,\n        uid: taskUid,\n        errorMessage: error.message\n    };\n    context.postMessage(taskErrorMessage);\n}\nasync function runFunction(context, taskUid, fn, args) {\n    try {\n        let res = fn(...args);\n        if (res instanceof Promise)\n            res = await res;\n        postWorkerTaskResultMessage(context, taskUid, res);\n    }\n    catch (error) {\n        postWorkerTaskErrorMessage(context, taskUid, error);\n    }\n}\nlet workerApiExposed = false;\nconst workerScope = self;\nif ((0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.isDedicatedWorkerScope)(workerScope)) {\n    workerScope.addEventListener("error", event => {\n        event.preventDefault();\n        postUncaughtErrorMessage(workerScope, event.error || event);\n    });\n    workerScope.addEventListener("unhandledrejection", event => {\n        event.preventDefault();\n        postUncaughtErrorMessage(workerScope, event.reason || event);\n    });\n}\nfunction exposeApi(api) {\n    (0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.assertWorkerScope)(workerScope);\n    if (workerApiExposed)\n        throw new Error("exposeApi() should only be called once.");\n    workerApiExposed = true;\n    const exposeApiInner = (context) => {\n        if (typeof api === "object" && api) {\n            context.onmessage = (event) => {\n                const eventContext = event.currentTarget;\n                const messageData = event.data;\n                switch (messageData.type) {\n                    case _shared_Messages_js__WEBPACK_IMPORTED_MODULE_0__.ControllerMessageType.Run:\n                        runFunction(eventContext, messageData.uid, api[messageData.method], messageData.args);\n                        break;\n                    case _shared_Messages_js__WEBPACK_IMPORTED_MODULE_0__.ControllerMessageType.Terminate:\n                        eventContext.close();\n                        if ((0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.isSharedWorkerScope)(workerScope)\n                            && messageData.forceTerminateShared) {\n                            workerScope.close();\n                        }\n                        break;\n                }\n            };\n            if (context instanceof MessagePort)\n                context.start();\n            const methodNames = Object.keys(api).filter(key => typeof api[key] === "function");\n            postModuleInitMessage(context, methodNames);\n        }\n        else {\n            throw new Error(`Invalid argument passed to exposeApi(). Expected an object, got: ${api}`);\n        }\n    };\n    if ((0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.isDedicatedWorkerScope)(workerScope))\n        exposeApiInner(workerScope);\n    else {\n        (0,_Utils_js__WEBPACK_IMPORTED_MODULE_2__.assertSharedWorkerScope)(workerScope);\n        workerScope.onconnect = (event) => {\n            const port = event.ports[0];\n            workerScope.onerror = event => {\n                event.preventDefault();\n                postUncaughtErrorMessage(port, event.error || event);\n            };\n            workerScope.onunhandledrejection = event => {\n                event.preventDefault();\n                postUncaughtErrorMessage(port, event.reason || event);\n            };\n            exposeApiInner(port);\n        };\n    }\n}\n\n\n//# sourceURL=webpack://dirtvz/./node_modules/threads-es/worker/Worker.js?')},"./wasmpkg/wasm_bg.wasm":(module,exports,__webpack_require__)=>{eval('/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./wasm_bg.js */ "./wasmpkg/wasm_bg.js");\nmodule.exports = __webpack_require__.v(exports, module.id, "027a52a16afbb4414645", {\n\t"./wasm_bg.js": {\n\t\t"__wbindgen_string_new": WEBPACK_IMPORTED_MODULE_0.__wbindgen_string_new,\n\t\t"__wbindgen_throw": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw\n\t}\n});\n\n//# sourceURL=webpack://dirtvz/./wasmpkg/wasm_bg.wasm?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];return void 0!==n||(n=__webpack_module_cache__[e]={id:e,loaded:!1,exports:{}},__webpack_modules__[e](n,n.exports,__webpack_require__),n.loaded=!0),n.exports}(()=>{var c="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",d="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",l="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",w=e=>{e&&!e.d&&(e.d=1,e.forEach(e=>e.r--),e.forEach(e=>e.r--?e.r++:e()))};__webpack_require__.a=(e,n,t)=>{t&&((_=[]).d=1);var _,a,r,s,o=new Set,i=e.exports,p=new Promise((e,n)=>{s=n,r=e});p[d]=i,p[c]=e=>(_&&e(_),o.forEach(e),p.catch(e=>{})),e.exports=p,n(e=>{a=e.map(e=>{if(null!==e&&"object"==typeof e){if(e[c])return e;var n,t;if(e.then)return(n=[]).d=0,e.then(e=>{t[d]=e,w(n)},e=>{t[l]=e,w(n)}),(t={})[c]=e=>e(n),t}var r={};return r[c]=e=>{},r[d]=e,r});var t,r=()=>a.map(e=>{if(e[l])throw e[l];return e[d]}),e=new Promise(e=>{(t=()=>e(r)).r=0;var n=e=>e!==_&&!o.has(e)&&(o.add(e),e&&!e.d&&(t.r++,e.push(t)));a.map(e=>e[c](n))});return t.r?e:r()},e=>(e?s(p[l]=e):r(i),w(_))),_&&(_.d=0)}})(),__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.hmd=e=>((e=Object.create(e)).children||(e.children=[]),Object.defineProperty(e,"exports",{enumerable:!0,set:()=>{throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: "+e.id)}}),e),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__.v=(n,e,t,r)=>{t=fetch(__webpack_require__.p+""+t+".module.wasm");return"function"==typeof WebAssembly.instantiateStreaming?WebAssembly.instantiateStreaming(t,r).then(e=>Object.assign(n,e.instance.exports)):t.then(e=>e.arrayBuffer()).then(e=>WebAssembly.instantiate(e,r)).then(e=>Object.assign(n,e.instance.exports))},(()=>{__webpack_require__.g.importScripts&&(e=__webpack_require__.g.location+"");var e,n=__webpack_require__.g.document;if(!e&&n&&!(e=n.currentScript?n.currentScript.src:e)){var t=n.getElementsByTagName("script");if(t.length)for(var r=t.length-1;-1<r&&!e;)e=t[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=e})();var __webpack_exports__=__webpack_require__("./ts/worker.ts");return __webpack_exports__})());